// This code is auto-generated by the shader processor.

#[allow(unused_imports)]
use rafx::RafxResult;

#[allow(unused_imports)]
use rafx::framework::{
    DescriptorSetAllocator, DescriptorSetArc, DescriptorSetBindings, DescriptorSetInitializer,
    DescriptorSetWriter, DescriptorSetWriterContext, DynDescriptorSet, ImageViewResource,
    ResourceArc,
};

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct IndirectCommandStd140 {
    pub index_count: u32,    // +0 (size: 4)
    pub instance_count: u32, // +4 (size: 4)
    pub first_index: u32,    // +8 (size: 4)
    pub vertex_offset: i32,  // +12 (size: 4)
    pub first_instance: u32, // +16 (size: 4)
    pub _padding0: [u8; 12], // +20 (size: 12)
} // 32 bytes

impl Default for IndirectCommandStd140 {
    fn default() -> Self {
        IndirectCommandStd140 {
            index_count: <u32>::default(),
            instance_count: <u32>::default(),
            first_index: <u32>::default(),
            vertex_offset: <i32>::default(),
            first_instance: <u32>::default(),
            _padding0: [u8::default(); 12],
        }
    }
}

pub type IndirectCommandUniform = IndirectCommandStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct IndirectCommandStd430 {
    pub index_count: u32,    // +0 (size: 4)
    pub instance_count: u32, // +4 (size: 4)
    pub first_index: u32,    // +8 (size: 4)
    pub vertex_offset: i32,  // +12 (size: 4)
    pub first_instance: u32, // +16 (size: 4)
} // 20 bytes

pub type IndirectCommandPushConstant = IndirectCommandStd430;

pub type IndirectCommandBuffer = IndirectCommandStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct PerCullInfoStd140 {
    pub was_culled: u32,     // +0 (size: 4)
    pub _padding0: [u8; 12], // +4 (size: 12)
} // 16 bytes

impl Default for PerCullInfoStd140 {
    fn default() -> Self {
        PerCullInfoStd140 {
            was_culled: <u32>::default(),
            _padding0: [u8::default(); 12],
        }
    }
}

pub type PerCullInfoUniform = PerCullInfoStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct PerCullInfoStd430 {
    pub was_culled: u32, // +0 (size: 4)
} // 4 bytes

pub type PerCullInfoPushConstant = PerCullInfoStd430;

pub type PerCullInfoBuffer = PerCullInfoStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct TransformWithHistoryStd140 {
    pub current_model_matrix: [[f32; 4]; 4],  // +0 (size: 64)
    pub previous_model_matrix: [[f32; 4]; 4], // +64 (size: 64)
} // 128 bytes

impl Default for TransformWithHistoryStd140 {
    fn default() -> Self {
        TransformWithHistoryStd140 {
            current_model_matrix: <[[f32; 4]; 4]>::default(),
            previous_model_matrix: <[[f32; 4]; 4]>::default(),
        }
    }
}

pub type TransformWithHistoryUniform = TransformWithHistoryStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct TransformWithHistoryStd430 {
    pub current_model_matrix: [[f32; 4]; 4],  // +0 (size: 64)
    pub previous_model_matrix: [[f32; 4]; 4], // +64 (size: 64)
} // 128 bytes

pub type TransformWithHistoryPushConstant = TransformWithHistoryStd430;

pub type TransformWithHistoryBuffer = TransformWithHistoryStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct ConfigStd140 {
    pub view_matrix: [[f32; 4]; 4],        // +0 (size: 64)
    pub proj_matrix: [[f32; 4]; 4],        // +64 (size: 64)
    pub draw_data_count: u32,              // +128 (size: 4)
    pub indirect_first_command_index: u32, // +132 (size: 4)
    pub depth_mip_slice_count: u32,        // +136 (size: 4)
    pub viewport_width: u32,               // +140 (size: 4)
    pub viewport_height: u32,              // +144 (size: 4)
    pub z_near: f32,                       // +148 (size: 4)
    pub write_debug_output: u32,           // +152 (size: 4)
    pub _padding0: [u8; 4],                // +156 (size: 4)
} // 160 bytes

impl Default for ConfigStd140 {
    fn default() -> Self {
        ConfigStd140 {
            view_matrix: <[[f32; 4]; 4]>::default(),
            proj_matrix: <[[f32; 4]; 4]>::default(),
            draw_data_count: <u32>::default(),
            indirect_first_command_index: <u32>::default(),
            depth_mip_slice_count: <u32>::default(),
            viewport_width: <u32>::default(),
            viewport_height: <u32>::default(),
            z_near: <f32>::default(),
            write_debug_output: <u32>::default(),
            _padding0: [u8::default(); 4],
        }
    }
}

pub type ConfigUniform = ConfigStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct TransformStd140 {
    pub model_matrix: [[f32; 4]; 4], // +0 (size: 64)
} // 64 bytes

impl Default for TransformStd140 {
    fn default() -> Self {
        TransformStd140 {
            model_matrix: <[[f32; 4]; 4]>::default(),
        }
    }
}

pub type TransformUniform = TransformStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct TransformStd430 {
    pub model_matrix: [[f32; 4]; 4], // +0 (size: 64)
} // 64 bytes

pub type TransformPushConstant = TransformStd430;

pub type TransformBuffer = TransformStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct DrawDataStd140 {
    pub transform_index: u32, // +0 (size: 4)
    pub material_index: u32,  // +4 (size: 4)
    pub _padding0: [u8; 8],   // +8 (size: 8)
} // 16 bytes

impl Default for DrawDataStd140 {
    fn default() -> Self {
        DrawDataStd140 {
            transform_index: <u32>::default(),
            material_index: <u32>::default(),
            _padding0: [u8::default(); 8],
        }
    }
}

pub type DrawDataUniform = DrawDataStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct DrawDataStd430 {
    pub transform_index: u32, // +0 (size: 4)
    pub material_index: u32,  // +4 (size: 4)
} // 8 bytes

pub type DrawDataPushConstant = DrawDataStd430;

pub type DrawDataBuffer = DrawDataStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct BoundingSphereStd140 {
    pub position: [f32; 3], // +0 (size: 12)
    pub radius: f32,        // +12 (size: 4)
} // 16 bytes

impl Default for BoundingSphereStd140 {
    fn default() -> Self {
        BoundingSphereStd140 {
            position: <[f32; 3]>::default(),
            radius: <f32>::default(),
        }
    }
}

pub type BoundingSphereUniform = BoundingSphereStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct BoundingSphereStd430 {
    pub position: [f32; 3], // +0 (size: 12)
    pub radius: f32,        // +12 (size: 4)
} // 16 bytes

pub type BoundingSpherePushConstant = BoundingSphereStd430;

pub type BoundingSphereBuffer = BoundingSphereStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct DebugOutputStd430 {
    pub total_mesh_count: u32,                    // +0 (size: 4)
    pub culled_mesh_count: u32,                   // +4 (size: 4)
    pub total_primitive_count: u32,               // +8 (size: 4)
    pub culled_primitive_count: u32,              // +12 (size: 4)
    pub per_cull_info: [PerCullInfoStd430; 4000], // +16 (size: 16000)
} // 16016 bytes

pub type DebugOutputBuffer = DebugOutputStd430;

pub const CONFIG_DESCRIPTOR_SET_INDEX: usize = 0;
pub const CONFIG_DESCRIPTOR_BINDING_INDEX: usize = 0;
pub const ALL_DRAW_DATA_DESCRIPTOR_SET_INDEX: usize = 0;
pub const ALL_DRAW_DATA_DESCRIPTOR_BINDING_INDEX: usize = 1;
pub const ALL_BOUNDING_SPHERES_DESCRIPTOR_SET_INDEX: usize = 0;
pub const ALL_BOUNDING_SPHERES_DESCRIPTOR_BINDING_INDEX: usize = 2;
pub const ALL_INDIRECT_COMMANDS_DESCRIPTOR_SET_INDEX: usize = 0;
pub const ALL_INDIRECT_COMMANDS_DESCRIPTOR_BINDING_INDEX: usize = 3;
pub const DEPTH_MIP_SLICES_DESCRIPTOR_SET_INDEX: usize = 0;
pub const DEPTH_MIP_SLICES_DESCRIPTOR_BINDING_INDEX: usize = 4;
pub const SMP_DESCRIPTOR_SET_INDEX: usize = 0;
pub const SMP_DESCRIPTOR_BINDING_INDEX: usize = 5;
pub const DEBUG_OUTPUT_DESCRIPTOR_SET_INDEX: usize = 0;
pub const DEBUG_OUTPUT_DESCRIPTOR_BINDING_INDEX: usize = 6;

pub struct DescriptorSet0Args<'a> {
    pub config: &'a ConfigUniform,
    pub depth_mip_slices: &'a [Option<&'a ResourceArc<ImageViewResource>>; 16],
    pub debug_output: &'a DebugOutputBuffer,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet0Args<'a> {
    type Output = DescriptorSet0;

    fn create_dyn_descriptor_set(
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> Self::Output {
        let mut descriptor = DescriptorSet0(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(
        descriptor_set_allocator: &mut DescriptorSetAllocator,
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> RafxResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

impl<'a> DescriptorSetWriter<'a> for DescriptorSet0Args<'a> {
    fn write_to(
        descriptor_set: &mut DescriptorSetWriterContext,
        args: Self,
    ) {
        descriptor_set.set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, args.config);
        descriptor_set.set_images(
            DEPTH_MIP_SLICES_DESCRIPTOR_BINDING_INDEX as u32,
            args.depth_mip_slices,
        );
        descriptor_set.set_buffer_data(
            DEBUG_OUTPUT_DESCRIPTOR_BINDING_INDEX as u32,
            args.debug_output,
        );
    }
}

pub struct DescriptorSet0(pub DynDescriptorSet);

impl DescriptorSet0 {
    pub fn set_args_static(
        descriptor_set: &mut DynDescriptorSet,
        args: DescriptorSet0Args,
    ) {
        descriptor_set.set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, args.config);
        descriptor_set.set_images(
            DEPTH_MIP_SLICES_DESCRIPTOR_BINDING_INDEX as u32,
            args.depth_mip_slices,
        );
        descriptor_set.set_buffer_data(
            DEBUG_OUTPUT_DESCRIPTOR_BINDING_INDEX as u32,
            args.debug_output,
        );
    }

    pub fn set_args(
        &mut self,
        args: DescriptorSet0Args,
    ) {
        self.set_config(args.config);
        self.set_depth_mip_slices(args.depth_mip_slices);
        self.set_debug_output(args.debug_output);
    }

    pub fn set_config(
        &mut self,
        config: &ConfigUniform,
    ) {
        self.0
            .set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, config);
    }

    pub fn set_depth_mip_slices(
        &mut self,
        depth_mip_slices: &[Option<&ResourceArc<ImageViewResource>>; 16],
    ) {
        self.0.set_images(
            DEPTH_MIP_SLICES_DESCRIPTOR_BINDING_INDEX as u32,
            depth_mip_slices,
        );
    }

    pub fn set_depth_mip_slices_element(
        &mut self,
        index: usize,
        element: &ResourceArc<ImageViewResource>,
    ) {
        self.0.set_image_at_index(
            DEPTH_MIP_SLICES_DESCRIPTOR_BINDING_INDEX as u32,
            index,
            element,
        );
    }

    pub fn set_debug_output(
        &mut self,
        debug_output: &DebugOutputBuffer,
    ) {
        self.0
            .set_buffer_data(DEBUG_OUTPUT_DESCRIPTOR_BINDING_INDEX as u32, debug_output);
    }

    pub fn flush(
        &mut self,
        descriptor_set_allocator: &mut DescriptorSetAllocator,
    ) -> RafxResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_struct_indirect_command_std140() {
        assert_eq!(std::mem::size_of::<IndirectCommandStd140>(), 32);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(IndirectCommandStd140, index_count), 0);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(IndirectCommandStd140, instance_count),
            4
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(IndirectCommandStd140, first_index), 8);
        assert_eq!(std::mem::size_of::<i32>(), 4);
        assert_eq!(std::mem::align_of::<i32>(), 4);
        assert_eq!(
            memoffset::offset_of!(IndirectCommandStd140, vertex_offset),
            12
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(IndirectCommandStd140, first_instance),
            16
        );
        assert_eq!(std::mem::size_of::<[u8; 12]>(), 12);
        assert_eq!(std::mem::align_of::<[u8; 12]>(), 1);
        assert_eq!(memoffset::offset_of!(IndirectCommandStd140, _padding0), 20);
    }

    #[test]
    fn test_struct_indirect_command_std430() {
        assert_eq!(std::mem::size_of::<IndirectCommandStd430>(), 20);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(IndirectCommandStd430, index_count), 0);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(IndirectCommandStd430, instance_count),
            4
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(IndirectCommandStd430, first_index), 8);
        assert_eq!(std::mem::size_of::<i32>(), 4);
        assert_eq!(std::mem::align_of::<i32>(), 4);
        assert_eq!(
            memoffset::offset_of!(IndirectCommandStd430, vertex_offset),
            12
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(IndirectCommandStd430, first_instance),
            16
        );
    }

    #[test]
    fn test_struct_per_cull_info_std140() {
        assert_eq!(std::mem::size_of::<PerCullInfoStd140>(), 16);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(PerCullInfoStd140, was_culled), 0);
        assert_eq!(std::mem::size_of::<[u8; 12]>(), 12);
        assert_eq!(std::mem::align_of::<[u8; 12]>(), 1);
        assert_eq!(memoffset::offset_of!(PerCullInfoStd140, _padding0), 4);
    }

    #[test]
    fn test_struct_per_cull_info_std430() {
        assert_eq!(std::mem::size_of::<PerCullInfoStd430>(), 4);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(PerCullInfoStd430, was_culled), 0);
    }

    #[test]
    fn test_struct_transform_with_history_std140() {
        assert_eq!(std::mem::size_of::<TransformWithHistoryStd140>(), 128);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(
            memoffset::offset_of!(TransformWithHistoryStd140, current_model_matrix),
            0
        );
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(
            memoffset::offset_of!(TransformWithHistoryStd140, previous_model_matrix),
            64
        );
    }

    #[test]
    fn test_struct_transform_with_history_std430() {
        assert_eq!(std::mem::size_of::<TransformWithHistoryStd430>(), 128);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(
            memoffset::offset_of!(TransformWithHistoryStd430, current_model_matrix),
            0
        );
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(
            memoffset::offset_of!(TransformWithHistoryStd430, previous_model_matrix),
            64
        );
    }

    #[test]
    fn test_struct_config_std140() {
        assert_eq!(std::mem::size_of::<ConfigStd140>(), 160);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, view_matrix), 0);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, proj_matrix), 64);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, draw_data_count), 128);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(ConfigStd140, indirect_first_command_index),
            132
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(ConfigStd140, depth_mip_slice_count),
            136
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, viewport_width), 140);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, viewport_height), 144);
        assert_eq!(std::mem::size_of::<f32>(), 4);
        assert_eq!(std::mem::align_of::<f32>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, z_near), 148);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, write_debug_output), 152);
        assert_eq!(std::mem::size_of::<[u8; 4]>(), 4);
        assert_eq!(std::mem::align_of::<[u8; 4]>(), 1);
        assert_eq!(memoffset::offset_of!(ConfigStd140, _padding0), 156);
    }

    #[test]
    fn test_struct_transform_std140() {
        assert_eq!(std::mem::size_of::<TransformStd140>(), 64);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(TransformStd140, model_matrix), 0);
    }

    #[test]
    fn test_struct_transform_std430() {
        assert_eq!(std::mem::size_of::<TransformStd430>(), 64);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(TransformStd430, model_matrix), 0);
    }

    #[test]
    fn test_struct_draw_data_std140() {
        assert_eq!(std::mem::size_of::<DrawDataStd140>(), 16);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(DrawDataStd140, transform_index), 0);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(DrawDataStd140, material_index), 4);
        assert_eq!(std::mem::size_of::<[u8; 8]>(), 8);
        assert_eq!(std::mem::align_of::<[u8; 8]>(), 1);
        assert_eq!(memoffset::offset_of!(DrawDataStd140, _padding0), 8);
    }

    #[test]
    fn test_struct_draw_data_std430() {
        assert_eq!(std::mem::size_of::<DrawDataStd430>(), 8);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(DrawDataStd430, transform_index), 0);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(DrawDataStd430, material_index), 4);
    }

    #[test]
    fn test_struct_bounding_sphere_std140() {
        assert_eq!(std::mem::size_of::<BoundingSphereStd140>(), 16);
        assert_eq!(std::mem::size_of::<[f32; 3]>(), 12);
        assert_eq!(std::mem::align_of::<[f32; 3]>(), 4);
        assert_eq!(memoffset::offset_of!(BoundingSphereStd140, position), 0);
        assert_eq!(std::mem::size_of::<f32>(), 4);
        assert_eq!(std::mem::align_of::<f32>(), 4);
        assert_eq!(memoffset::offset_of!(BoundingSphereStd140, radius), 12);
    }

    #[test]
    fn test_struct_bounding_sphere_std430() {
        assert_eq!(std::mem::size_of::<BoundingSphereStd430>(), 16);
        assert_eq!(std::mem::size_of::<[f32; 3]>(), 12);
        assert_eq!(std::mem::align_of::<[f32; 3]>(), 4);
        assert_eq!(memoffset::offset_of!(BoundingSphereStd430, position), 0);
        assert_eq!(std::mem::size_of::<f32>(), 4);
        assert_eq!(std::mem::align_of::<f32>(), 4);
        assert_eq!(memoffset::offset_of!(BoundingSphereStd430, radius), 12);
    }

    #[test]
    fn test_struct_debug_output_std430() {
        assert_eq!(std::mem::size_of::<DebugOutputStd430>(), 16016);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(DebugOutputStd430, total_mesh_count),
            0
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(DebugOutputStd430, culled_mesh_count),
            4
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(DebugOutputStd430, total_primitive_count),
            8
        );
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(
            memoffset::offset_of!(DebugOutputStd430, culled_primitive_count),
            12
        );
        assert_eq!(std::mem::size_of::<[PerCullInfoStd430; 4000]>(), 16000);
        assert_eq!(std::mem::align_of::<[PerCullInfoStd430; 4000]>(), 4);
        assert_eq!(memoffset::offset_of!(DebugOutputStd430, per_cull_info), 16);
    }
}
